import unittest
import pandas as pd
from pandas import DataFrame
import numpy as np
from igraph import Graph
import copy
from sklearn.metrics import jaccard_score


from knowledge_infusion.graph_embeddings.subgraph_embedding import SubGraphEmbedding
from knowledge_infusion.graph_embeddings.node_embeddings import NodeEmbeddings
from data_provider.synthetic_data_generation.config.sdg_config import SdgConfig
from data_provider.synthetic_data_provider import SyntheticDataProvider


class TestSubgraphEmbedding(unittest.TestCase):
    """
    This class tests the Subgraphembedding
    """

    def setUp(self):
        # Setup a minimal infrastructure 
        folder = "test/subgraph_embedding_data/"
        sgdConfig = SdgConfig.create_config('knowledge_infusion/eval_with_synth_data/configs/sdg/default_config_sdg.json')
        data_provider_class = SyntheticDataProvider(sgdConfig)
        self._node_embeddings = NodeEmbeddings(
            base_folder=folder,
            data_provider=data_provider_class,
            node_embeddings=None,
            use_head=True,
            type="TransE",
            kg_type='unquantified'
        )

        # Build a minimal graph containing 3 relations. The graph is build to be of the representation
        # quantified_params_with_literal
        graph = Graph(directed=True)
        parameters = ["p1", "p2"]
        parameters_attributes = {'type': ['parameter'] * len(parameters)}
        graph.add_vertices(parameters, parameters_attributes)

        qualities = ["q1", "q2"]
        qualities_attributes = {'type': ['qual_influence'] * len(qualities)}
        graph.add_vertices(qualities, qualities_attributes)

        literals = ["5", "4", "3"]
        graph.add_vertices(literals)

        graph.add_edges([
            ("q1", "p1"), # Quality implies parameter
            ("q1", "5"),  # Quality implies literal
            ("5", "p1"),  # Literal quantifies parameter

            ("q1", "p2"),
            ("q1", "4"),
            ("4", "p2"),

            ("q2", "p1"),
            ("q2", "3"),
            ("3", "p1")
        ])
        self._node_embeddings._graph = graph

        # Set the node embedding, that would normally be generated by i.e. pykeen
        # Dimensionality=3 so that the asserted values can be calculated manually
        self._node_embeddings.embeddings = DataFrame(np.array([
            [1, 2, 3],
            [4, 5, 6],
            [6, 7, 8],
            [9, 0, 1],
            [2, 3, 4],
            [5, 6, 7],
            [8, 9, 0]
        ]))

        # Bring the graph in the correct form
        self._node_embeddings._metadata = self._node_embeddings._graph.get_vertex_dataframe()

        self._node_embeddings.edges = self._node_embeddings._graph.get_edge_dataframe().rename(columns={'source': 'from', 'target': 'to'})
        self._node_embeddings._graph = Graph.DataFrame(self._node_embeddings.edges, directed=True)


    def test_hopping(self):
        """
        This test checks if the hopping propagation works correctly
        """

        # Create the class
        skg_emb = SubGraphEmbedding(self._node_embeddings, None, 'jaccard', False, 2, self._node_embeddings._graph, "test", startnodeid=2, embedding_dim=3)
        hops = skg_emb.n_hop_propagation(2)
        hops_as_arr = []
        # Save the done hops as pair
        for hop in hops:
            hops_as_arr.append((self._node_embeddings._metadata.loc[hop.source]['name'], self._node_embeddings._metadata.loc[hop.target]['name']))

        # List of expected hops
        compared_to = [
            ("q1", "p1"), # Quality implies parameter
            ("q1", "5"),  # Quality implies literal
            ("5", "p1"),  # Literal quantifies parameter

            ("q1", "p2"),
            ("q1", "4"),
            ("4", "p2")
        ]
        # Deepcopy for list operations in loop
        copied = copy.deepcopy(compared_to)
        # If done hop is in expected hops remove it from the list
        # If a not expected hop is done test fails with an excepion
        # If an expected hop is not done test fails cause of assert
        # TODO try with sets
        for element in compared_to:
            for hop in hops_as_arr:
                if element == hop:
                    copied.remove(element)

        self.assertTrue(len(copied) == 0)

    def test_calculation(self):
        """
        This function tests wether the caculated SubKG embeddings are correct.
        In order to generate the data to which the result of the Embedding should
        be compared to. One must calculate the embeddings by hand. Using the 
        following formula:
        no head:
            SumOf(tail_embedding * distance(head_embedding, tail_embedding))
        
        For use head add the original head embedding to the sum.
        """
        # Create the class
        skg_emb = SubGraphEmbedding(self._node_embeddings, None, 'euclidean', False, 2, self._node_embeddings._graph, "test", startnodeid=3, embedding_dim=3)
        # Hand calculated values. (nohead)
        expected = np.array([91.7128, 119.6526, 56.4881])
        self.assertTrue(np.array_equal(np.round(skg_emb.embedding,4), expected))

        skg_emb = SubGraphEmbedding(self._node_embeddings, None, 'euclidean', True, 2, self._node_embeddings._graph, "test", startnodeid=3, embedding_dim=3)
        # Hand calculated values (with_head)
        expected = np.array([100.7128, 119.6526, 57.4881])
        self.assertTrue(np.array_equal(np.round(skg_emb.embedding,4), expected))
        


    def test_1_hop(self):
        """
        This tests, wether the original 1hop SubKG-Embedding method yields the same results as
        the newer n-hop SubKG embedding with n=1
        """
        # Setup using real data of 48 dimensions
        folder = "test/subgraph_embedding_data/"
        sgdConfig = SdgConfig.create_config('knowledge_infusion/eval_with_synth_data/configs/sdg/default_config_sdg.json')
        data_provider_class = SyntheticDataProvider(sgdConfig)
        node_embeddings = NodeEmbeddings(
            base_folder=folder,
            data_provider=data_provider_class,
            node_embeddings=None,
            use_head=True,
            type="TransE",
            kg_type='unquantified'
        )
        vertecies = node_embeddings.metadata
        ig = Graph.DataFrame(node_embeddings.edges, directed = True)
        skg_lut_classic = DataFrame(np.vstack([SubGraphEmbedding(node_embeddings, node_embeddings.edges.loc[node_embeddings.edges['from'] == idx], "jaccard", False).embedding.T for idx in vertecies.loc[vertecies['type'] == 'qual_influence'].index.values]))
        skg_lut_new = DataFrame(np.vstack([SubGraphEmbedding(node_embeddings, None, 'jaccard', False, 2, ig, "test", idx).embedding.T for idx in vertecies.loc[vertecies['type'] == 'qual_influence'].index.values]))
        np_classic = skg_lut_classic.to_numpy()
        np_new = skg_lut_new.to_numpy()

        results_are_equal = True
        for i in range(len(np_classic)):
            for u in range(len(np_classic[0])):
                if round(np_classic[i][u],10) != round(np_new[i][u], 10):
                    results_are_equal = False
        
        self.assertTrue(results_are_equal)


if __name__ == "__main__":
    unittest.main()