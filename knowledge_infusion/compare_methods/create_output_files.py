import pickle
from typing import List
import pandas as pd
import os
import glob

from knowledge_infusion.compare_methods.compare_methods import matches_at_k_result, EMBEDDING_TYPES
from data_provider.synthetic_data_generation.config.modules.knowledge_graph_generator_config import KnowledgeGraphGeneratorType

INCLUDE_STD = True

class TableCreator:
    """
    This Class processes the Embeddings generated by CompareMethods and exports them to various File formats
    """

    @staticmethod
    def read_init_pickle(path):
        """
        Reads the pickle generated by CompareMethods
        """
        with open(path + 'results.pickle', 'rb') as f:
            loaded = pickle.load(f)

        for element in loaded:
            element.mean = element.mean[0]
        return loaded


    @staticmethod
    def split_by_k(entries: List[matches_at_k_result]):
        """
        Splits the data into two bins by k
        """
        k_equals_5 = []
        k_equals_3 = []

        for entry in entries:
            if entry.k == '5':
                k_equals_5.append(entry)
            elif entry.k == '3':
                k_equals_3.append(entry)

        return (k_equals_3, k_equals_5)


    @staticmethod
    def create_df(entries: List[matches_at_k_result]):
        """
        Creates Pandas Dataframe from List of evaluated Embeddings
        """
        kgs = []
        for kgtype in KnowledgeGraphGeneratorType:
            kgs.append(kgtype.value)
        cols = pd.MultiIndex.from_product([kgs, [1, 0], ['euc', 'jac']], names=['Representations', 'Use Head', 'Distance'])
        rows = EMBEDDING_TYPES

        df = pd.DataFrame(None, index=EMBEDDING_TYPES, columns=cols)
        
        for entry in entries:
            if entry.use_head:
                x = 1
            else:
                x = 0
            if INCLUDE_STD:
                df.at[entry.embedding, (entry.representation.value, x, entry.distance_measure)] = str(entry.mean.round(2)) + ' Â± ' + str(round(entry.std[0],2))
            else:
                df.at[entry.embedding, (entry.representation.value, x, entry.distance_measure)] = entry.mean.round(2)
        return df

    @staticmethod
    def average_data(og: List[matches_at_k_result], new: List[matches_at_k_result]):
        from statistics import mean, stdev

        for element in og:
            matching = []
            matching.append(element)
            for addition in new:
                if element.distance_measure == addition.distance_measure and element.embedding == addition.embedding and element.representation == addition.representation and element.use_head == addition.use_head:
                    matching.append(addition)
            means = []
            for item in matching:
                means.append(item.mean)
            element.mean = mean(means)
            element.std = [stdev(means)]
        
        return og

    
    @staticmethod
    def save_all(k3, k5, data_folder):
        if INCLUDE_STD:
            ending = "_with_std"
        else:
            ending = ""


        df3 = TableCreator.create_df(k3)
        df3 = df3.drop(columns=['quantified_conditions'])
        df3 = df3.transpose()
        df5 = TableCreator.create_df(k5)
        df5 = df5.drop(columns=['quantified_conditions'])
        df5 = df5.transpose()

        if not os.path.isdir(data_folder):
            os.makedirs(data_folder)

        with open(data_folder + 'k3_table' + ending +'.csv', 'w') as f:
            df3.to_csv(f, sep=";")
        with open(data_folder + 'k3_table' + ending +'.xlsx', 'wb') as f:
            df3.to_excel(f)
        with open(data_folder + 'k3_table' + ending +'.tex', 'w') as f:
            df3.to_latex(f)

        with open(data_folder + 'k5_table' + ending +'.csv', 'w') as f:
            df5.to_csv(f, sep=";")
        with open(data_folder + 'k5_table' + ending +'.xlsx', 'wb') as f:
            df5.to_excel(f)
        with open(data_folder + 'k5_table' + ending +'.tex', 'w') as f:
            df5.to_latex(f)


    @classmethod
    def create_tables_from_evaluation_result_pickle(cls, path):
        """
        Alters the created Dataframes and exports them as CSV, XLSX, Tex
        """

        data = cls.read_init_pickle(path)
        k3, k5 = cls.split_by_k(data)
        
        data_folder = path + "_table_format/"
        cls.save_all(k3,k5, data_folder)
        
        print("SUCCESS")

    @classmethod
    def combine_multiple_table(cls, paths, final_path):
        og_k3 = []
        og_k5 = []
        k3_list = []
        k5_list = []

        for i in range(len(paths)):
            path = paths[i]
            data = cls.read_init_pickle(path)
            k3, k5 = cls.split_by_k(data)
            if i == 0:
                og_k3 = k3
                og_k5 = k5
            else:
                for k in k3:
                    k3_list.append(k)
                for k in k5:
                    k5_list.append(k)

        k3 = cls.average_data(og_k3, k3_list)
        k5 = cls.average_data(og_k5, k5_list)
        
        data_folder = final_path + "_tables/"
        cls.save_all(k3, k5, data_folder)
        


if __name__ == "__main__":
    base_path = "knowledge_infusion/compare_methods/results/"
    number_iters = len(glob.glob(base_path + 'iteration*'))

    paths = []
    for i in range(number_iters):
        paths.append(base_path + "iteration" + str(i) + "/")

    for path in paths:  
        TableCreator.create_tables_from_evaluation_result_pickle(path)
    
    TableCreator.combine_multiple_table(paths, base_path)

    INCLUDE_STD = not INCLUDE_STD

    base_path = "knowledge_infusion/compare_methods/results/"

    paths = []
    for i in range(number_iters):
        paths.append(base_path + "iteration" + str(i) + "/")

    for path in paths:  
        TableCreator.create_tables_from_evaluation_result_pickle(path)
    
    TableCreator.combine_multiple_table(paths, base_path)

